Infrastructure_Graph_Analyzer–Python+NetworkX


This project models a microservices-based infrastructure using graph theory and performs several types of analysis, including:

Directed graph construction

Visualization of system dependencies

Latency-based bottleneck detection

Node metadata enrichment

Degree, Closeness, and Betweenness centrality

Automated report generation (TXT)

Dynamic drawing of architecture graphs

The system ingests its data from Excel files, allowing dynamic loading of clusters, services, nodes, and latencies.

Section: Problem Statement

The goal of this project is to model a basic IT infrastructure for a web application (e.g., an online store) using a directed graph.
The purpose is to represent how different system components communicate (client, frontend, backend, database, cache, identity provider, etc.) and assign latency values to each connection to identify potential bottlenecks or critical services.

Nodes (services) included in the model
Node	Alias	Description
Client	C	End user / browser making the request
Load Balancer	LB	Distributes incoming traffic (e.g., ALB/NLB)
Web Server	WS	Frontend service (e.g., Nginx)
Application Server	AS	Backend service / API
Identity Provider	IP	Authentication system (tokens, login, OAuth)
Database	D	Primary relational database (MySQL/PostgreSQL)
Cache	CH	In-memory cache (e.g., Redis, ElastiCache)
Message Queue	MQ	Background job processing (SQS, RabbitMQ)
Logging Service	LS	Observability/log monitoring (ELK, CloudWatch, etc.)

Each node represents a separate microservice or infrastructure component.

Directed edges indicate request flow

For example:

Client → LoadBalancer

LoadBalancer → WebServer

WebServer → AppServer

AppServer → IdentityProvider

AppServer → Database

AppServer → Cache

AppServer → MessageQueue

AppServer → LoggingService

IdentityProvider → Database

MessageQueue → LoggingService

Each directed edge represents a dependency or API call.

Latency as edge weights

Each edge in the graph includes a latency value (ms) representing request cost:

Edge	Meaning	Latency (ms)
C → LB	User request to entry point	80
LB → WS	Load balancer forwards request	10
WS → AS	Frontend → Backend call	5
AS → D	Database query	25
AS → CH	Cache lookup	3
AS → IP	Authentication request	8
IP → D	DB lookup by auth service	20
AS → MQ	Background job push	4
AS → LS	Log emission	2
MQ → LS	Queue event logging	2

This graph allows us to analyze:

Communication paths

Bottlenecks caused by high latency

Central services using graph centrality metrics

Critical nodes that connect multiple parts of the system

1. Project Objective

This project simulates an IT infrastructure (such as an e-commerce application) using graph theory.
Each component of the architecture—frontend, backend, cache, database, load balancer, etc.—is represented as a node, and each interaction between services is represented as a directed edge with an associated latency (weight).

The goal is to:

Visualize the full architecture

Identify bottlenecks

Measure the importance of each service in the network

Generate reports for analysis

2. Technologies Used
Component	Technology
Language	Python
Graph engine	NetworkX
Visualization	Matplotlib
Data input	Pandas + Excel
Reporting	TXT generation
Layout	Planar / Spring graph layouts
3. Excel Input Files
informacion_cluster.xlsx

Contains node metadata:

clave	nombre	servicio	cluster
C	Cluster_01	AWS	cluster01
LB	ALB_01	Load Balancer	cluster01
WS	Nginx	Pod EKS	cluster01
...	...	...	...
aristas.xlsx

Contains edges and latencies:

u	v	weight	cluster
C	LB	80	cluster01
LB	WS	10	cluster01
AS	D	25	cluster01
...	...	...	...
4. Implemented Graph Analysis
Degree Centrality

Measures how many direct connections each node has.

Closeness Centrality

Measures how fast a node can reach all others.

Betweenness Centrality

Measures how often a node appears in the shortest paths, identifying critical bridges in the infrastructure.

A detailed report is generated under:

/reportes/reporte_cluster01.txt
/reportes/reporte_cluster02.txt

5. Graph Visualization

Nodes include:

Labels (node ID)

Secondary labels (service type)

Colors: blue nodes, red edges

Latency values shown on edges

Planar layout for clear visualization

Example output:

[Graph image generated by Matplotlib]


(You can add a screenshot after committing your code)

6. Bottleneck Detection

The program automatically detects the edge with the highest latency, identifying the system’s current bottleneck:

Bottleneck: ('C', 'LB') – latency 80ms – cluster01

7. How to Run
Requirements

Install dependencies:

pip install networkx pandas matplotlib openpyxl

Run the application:
python grafo_V2.py

Choose which cluster to analyze:
Which cluster would you like to analyze? (cluster01 / cluster02):


The program will:

Load nodes

Load edges

Draw the graph

Detect bottlenecks

Generate a centrality report